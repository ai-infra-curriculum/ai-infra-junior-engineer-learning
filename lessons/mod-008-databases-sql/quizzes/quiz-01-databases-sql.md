# Module 008 Quiz: Databases & SQL

## Quiz Information

- **Module:** Databases & SQL
- **Total Questions:** 50
- **Time Limit:** 75 minutes
- **Passing Score:** 80% (40/50 correct)
- **Topics Covered:**
  - Database fundamentals and PostgreSQL architecture
  - SQL syntax from basics to advanced analytics
  - Schema design, normalization, and constraints
  - Transactions, concurrency, and indexing
  - Python integration with SQLAlchemy and migrations
  - Operational excellence (monitoring, optimization, governance)

## Instructions

1. Read each question carefully and choose the best answer.
2. Unless noted, each question has a single correct answer.
3. Highlighting keywords before answering can reduce common mistakes.
4. You may navigate between questions before submitting the quiz.
5. A score report with explanations will be provided after submission.

---

## Section 1: Database Fundamentals (10 questions)

### Question 1
Which ACID property ensures that either all statements in a transaction succeed or none of them do?

A) Atomicity  
B) Consistency  
C) Isolation  
D) Durability

**Correct Answer:** A  
**Explanation:** Atomicity guarantees that a transaction is treated as an indivisible unit; if any part fails, the whole transaction is rolled back.

---

### Question 2
What is the primary purpose of a foreign key constraint?

A) Enforce value ranges on numeric columns  
B) Ensure uniqueness across multiple columns  
C) Maintain referential integrity between related tables  
D) Automatically create indexes on joined columns

**Correct Answer:** C  
**Explanation:** Foreign keys link rows between tables and prevent orphaned records, thereby enforcing referential integrity.

---

### Question 3
In the CAP theorem, which trade-off do most distributed SQL databases like CockroachDB or Google Spanner attempt to balance?

A) Consistency vs Availability  
B) Availability vs Partition tolerance  
C) Consistency vs Partition tolerance  
D) Latency vs Throughput

**Correct Answer:** C  
**Explanation:** Distributed SQL systems typically sacrifice some availability in favor of strong consistency while tolerating partitions.

---

### Question 4
Which PostgreSQL feature allows storing semi-structured data with indexing support?

A) ARRAY  
B) JSONB  
C) HSTORE  
D) BYTEA

**Correct Answer:** B  
**Explanation:** JSONB stores JSON in a binary representation that supports indexing and efficient querying.

---

### Question 5
What does the `ANALYZE` command do in PostgreSQL?

A) Rebuilds all indexes in the database  
B) Updates table statistics used by the query planner  
C) Checks table integrity and repairs corruption  
D) Forces a checkpoint to flush WAL to disk

**Correct Answer:** B  
**Explanation:** ANALYZE collects statistics about table contents so the planner can choose optimal execution strategies.

---

### Question 6
Which normalization form eliminates transitive dependencies (non-key attribute depending on another non-key attribute)?

A) First Normal Form (1NF)  
B) Second Normal Form (2NF)  
C) Third Normal Form (3NF)  
D) Boyce-Codd Normal Form (BCNF)

**Correct Answer:** C  
**Explanation:** 3NF removes transitive dependencies, ensuring that non-key attributes depend only on the key.

---

### Question 7
What is the typical consequence of using `SELECT *` in production queries?

A) Queries run faster because all columns are cached  
B) It prevents the use of covering indexes  
C) It automatically enforces projection pushdown  
D) It renames duplicate columns automatically

**Correct Answer:** B  
**Explanation:** `SELECT *` can reduce index effectiveness and increases I/O by returning unnecessary columns, making covering indexes useless.

---

### Question 8
Which PostgreSQL role capability grants the ability to create new databases?

A) `CREATEROLE`  
B) `CREATEUSER`  
C) `CREATEDB`  
D) `SUPERUSER`

**Correct Answer:** C  
**Explanation:** `CREATEDB` allows a role to create databases. `CREATEROLE` manages roles; `SUPERUSER` bypasses checks entirely.

---

### Question 9
What is the main benefit of using sequences (e.g., `SERIAL`, `GENERATED BY DEFAULT AS IDENTITY`) for primary keys?

A) They guarantee gapless IDs  
B) They ensure unique and incremental identifiers with low contention  
C) They automatically create foreign key relationships  
D) They prevent the need for primary key indexes

**Correct Answer:** B  
**Explanation:** Sequences produce unique incremental values efficiently, minimizing contention even under concurrent inserts.

---

### Question 10
Which backup strategy allows capturing point-in-time recovery (PITR) in PostgreSQL?

A) Periodic `COPY` commands  
B) File-system snapshots only  
C) Base backup plus continuous WAL archiving  
D) Exporting schemas with `pg_dump --schema-only`

**Correct Answer:** C  
**Explanation:** PITR requires a base backup and archived WAL segments so the database can be restored to any moment.

---

## Section 2: SQL Mastery & Query Optimization (12 questions)

### Question 11
Given the query `SELECT COUNT(*) FROM runs WHERE status = 'succeeded';`, which index would improve performance most?

A) `CREATE INDEX idx_runs_status ON runs(status);`  
B) `CREATE INDEX idx_runs_count ON runs(count);`  
C) `CREATE INDEX idx_runs_status_count ON runs(status, COUNT(*));`  
D) `CREATE INDEX idx_runs_status_created ON runs(created_at);`

**Correct Answer:** A  
**Explanation:** Filtering on `status` benefits directly from an index on that column; other choices are invalid or unrelated.

---

### Question 12
Which SQL clause is evaluated first in the logical query processing order?

A) SELECT  
B) FROM  
C) WHERE  
D) ORDER BY

**Correct Answer:** B  
**Explanation:** The logical processing order starts with `FROM`, then `WHERE`, `GROUP BY`, `HAVING`, `SELECT`, `ORDER BY`, `LIMIT`.

---

### Question 13
What is a key difference between `INNER JOIN` and `LEFT JOIN`?

A) `LEFT JOIN` requires matching rows on both sides  
B) `INNER JOIN` returns all rows from the left table regardless of matches  
C) `LEFT JOIN` returns unmatched rows from the left table with NULLs on the right  
D) `INNER JOIN` is slower in all cases

**Correct Answer:** C  
**Explanation:** A left join includes all rows from the left table even if there’s no matching row on the right.

---

### Question 14
Which window function calculates the difference between a row and the previous row?

A) `RANK()`  
B) `ROW_NUMBER()`  
C) `LAG()`  
D) `NTILE()`

**Correct Answer:** C  
**Explanation:** `LAG()` accesses the value from a preceding row within the window partition.

---

### Question 15
What is the purpose of a CTE (Common Table Expression)?

A) Speed up all queries by default  
B) Provide a temporary named result set for readability and reuse  
C) Automatically create materialized views  
D) Replace JOIN operations

**Correct Answer:** B  
**Explanation:** CTEs improve readability and enable modular query composition; they don’t inherently speed queries without optimization.

---

### Question 16
Which of the following queries would benefit most from a BRIN index?

A) Random lookups on `uuid` primary keys  
B) Range scans on a monotonically increasing `created_at` column  
C) Equality filters on enumerated `status` values  
D) Joining on `model_name`

**Correct Answer:** B  
**Explanation:** BRIN indexes excel at large tables with natural ordering (e.g., timestamps), enabling efficient range scans.

---

### Question 17
What does `EXPLAIN (ANALYZE, BUFFERS)` provide that plain `EXPLAIN` does not?

A) Execution plan without running the query  
B) Actual runtime statistics and buffer usage  
C) Automatic index recommendations  
D) Locks held during execution

**Correct Answer:** B  
**Explanation:** `ANALYZE` executes the query and reports actual timing/rows, while `BUFFERS` details cache hits/misses.

---

### Question 18
Which SQL technique efficiently pivots rows into columns for reporting?

A) Window functions  
B) `GROUPING SETS`  
C) `CASE` expressions with aggregation  
D) `HAVING` clauses

**Correct Answer:** C  
**Explanation:** Conditional aggregation using `SUM(CASE WHEN ...)` is a common pivot pattern in PostgreSQL.

---

### Question 19
When using `SERIALIZABLE` isolation, what type of anomaly is the database preventing?

A) Dirty reads and non-repeatable reads only  
B) Phantom reads only  
C) Lost updates only  
D) All concurrency anomalies, mimicking serial execution

**Correct Answer:** D  
**Explanation:** SERIALIZABLE provides the strongest isolation, preventing all anomalies by guaranteeing serial equivalence.

---

### Question 20
In PostgreSQL, how can you ensure a query uses a specific index during troubleshooting?

A) Use the `FORCE INDEX` clause  
B) Temporarily disable sequential scans via `SET enable_seqscan = off;`  
C) Wrap the query in a transaction  
D) Create the index as `CLUSTERED`

**Correct Answer:** B  
**Explanation:** PostgreSQL doesn’t support FORCE INDEX, but you can influence the planner by disabling certain plan types temporarily.

---

### Question 21
Which approach removes duplicate rows while retaining the row with the latest timestamp?

A) `DELETE FROM ... WHERE ROWNUM > 1;`  
B) Use window function with `ROW_NUMBER()` and delete where rn > 1  
C) Create a unique index and rely on constraint violations  
D) Enable synchronous replication

**Correct Answer:** B  
**Explanation:** Assign `ROW_NUMBER()` over partitions ordered by timestamp, then delete rows where `rn > 1`.

---

### Question 22
What is the main difference between a materialized view and a regular view?

A) Materialized views cannot be refreshed  
B) Regular views store data on disk  
C) Materialized views persist data physically and require refreshes  
D) Regular views require indexes while materialized views do not

**Correct Answer:** C  
**Explanation:** Materialized views store the query result and must be refreshed; regular views are virtual and compute on access.

---

## Section 3: Application Integration & Operations (8 questions)

### Question 23
Which SQLAlchemy concept maps classes to database tables?

A) Session  
B) Declarative Base  
C) Mapper  
D) Engine

**Correct Answer:** B  
**Explanation:** The declarative base uses class definitions to define table mappings.

---

### Question 24
What is the recommended way to manage database sessions in FastAPI using SQLAlchemy 2.0 style?

A) Create a global session and reuse it across requests  
B) Use dependency injection to yield a session per request and close afterward  
C) Open and close sessions manually in each route function  
D) Use thread-local globals without cleanup

**Correct Answer:** B  
**Explanation:** FastAPI best practice is to provide a session via dependency injection (`yield`) ensuring proper cleanup per request.

---

### Question 25
Which tool generates migration scripts based on SQLAlchemy models?

A) Alembic  
B) Flyway  
C) Liquibase  
D) pgAdmin

**Correct Answer:** A  
**Explanation:** Alembic is built for SQLAlchemy migrations and integrates tightly with its metadata.

---

### Question 26
When preparing a migration that drops a column, what safety step should you take first?

A) Drop all dependent tables automatically  
B) Disable foreign key checks permanently  
C) Audit the column usage and stage data backup or view replacement  
D) Force clients to reconnect instantly

**Correct Answer:** C  
**Explanation:** Dropping columns can break clients; audit usage and create backups or compatibility views before removal.

---

### Question 27
Which metric best indicates whether query caching is effective in PostgreSQL?

A) Rows returned per second  
B) Index hit ratio (`idx_blks_hit / (idx_blks_read + idx_blks_hit)`)  
C) CPU utilization percentage  
D) Number of active connections

**Correct Answer:** B  
**Explanation:** A high index hit ratio signals queries are served from cache rather than disk, reflecting caching efficiency.

---

### Question 28
How can you prevent destructive changes from reaching production via CI/CD?

A) Skip database migrations in CI  
B) Run migrations directly on production to detect issues early  
C) Use migration linting and pre-deployment review steps  
D) Run tests against the production database nightly

**Correct Answer:** C  
**Explanation:** Automated migration linting (e.g., checking for locks, size) plus humans-in-the-loop reduce risk before deploy.

---

### Question 29
What is the primary purpose of connection pooling in SQLAlchemy?

A) Limit the number of tables queried simultaneously  
B) Cache ORM models in memory  
C) Reuse database connections to reduce overhead and latency  
D) Encrypt traffic between application and database

**Correct Answer:** C  
**Explanation:** Connection pools recycle connections, improving throughput and avoiding the cost of repeated connection handshakes.

---

### Question 30
You notice long-running reporting queries blocking writes. Which strategy helps without sacrificing strong consistency?

A) Lower the isolation level to `READ UNCOMMITTED`  
B) Create read replicas and route analytics queries to them  
C) Disable autovacuum temporarily  
D) Turn off synchronous commit

**Correct Answer:** B
**Explanation:** Directing read-heavy workloads to replicas isolates reporting traffic while maintaining consistency guarantees for writes on the primary.

---

## Section 4: Advanced SQL & Window Functions (10 questions)

### Question 31
Which window function assigns a unique sequential number within a partition, starting at 1 for each partition?

A) `RANK()`
B) `DENSE_RANK()`
C) `ROW_NUMBER()`
D) `NTILE()`

**Correct Answer:** C
**Explanation:** `ROW_NUMBER()` assigns unique sequential integers within each partition, useful for deduplication and pagination.

---

### Question 32
What is the key advantage of a recursive CTE in PostgreSQL?

A) It prevents infinite loops automatically
B) It allows querying hierarchical or graph-structured data
C) It improves performance over window functions
D) It enforces foreign key constraints

**Correct Answer:** B
**Explanation:** Recursive CTEs enable traversal of hierarchical data like org charts, dependency trees, or graph structures.

---

### Question 33
Given a query with `PARTITION BY experiment_name ORDER BY accuracy DESC`, what does the window function operate on?

A) All rows in the table
B) Only rows where accuracy is not NULL
C) Groups of rows sharing the same experiment_name
D) Rows ordered globally by accuracy

**Correct Answer:** C
**Explanation:** `PARTITION BY` divides rows into groups (partitions) before applying the window function within each group.

---

### Question 34
Which SQL clause allows you to filter window function results after computation?

A) WHERE
B) HAVING
C) Subquery or CTE wrapping the window function
D) PARTITION BY

**Correct Answer:** C
**Explanation:** Window functions cannot be used in WHERE or HAVING; wrap them in a subquery/CTE to filter results.

---

### Question 35
What does `LAG(accuracy, 2)` return in a window function?

A) The accuracy value from 2 rows ahead
B) The accuracy value from 2 rows behind
C) The second-highest accuracy value
D) The average of the current row and 2 previous rows

**Correct Answer:** B
**Explanation:** `LAG(column, offset)` accesses a value from `offset` rows before the current row.

---

### Question 36
Which index type is best for JSONB containment queries (`@>` operator) in PostgreSQL?

A) B-tree
B) Hash
C) GIN (Generalized Inverted Index)
D) BRIN

**Correct Answer:** C
**Explanation:** GIN indexes efficiently handle JSONB containment, existence, and path queries.

---

### Question 37
What is the primary benefit of a `LATERAL` join in PostgreSQL?

A) It eliminates NULL values automatically
B) It allows a subquery to reference columns from preceding tables in the FROM clause
C) It creates temporary tables
D) It enforces referential integrity

**Correct Answer:** B
**Explanation:** LATERAL enables correlated subqueries in the FROM clause, allowing cross-references between tables.

---

### Question 38
In a window function with `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`, what does the frame include?

A) Only the current row
B) All rows from the start of the partition to the current row
C) Only the previous row
D) All rows in the entire table

**Correct Answer:** B
**Explanation:** `UNBOUNDED PRECEDING` starts at the first row of the partition, and `CURRENT ROW` ends at the current position.

---

### Question 39
Which aggregate function can be used as a window function to calculate running totals?

A) `COUNT()`
B) `SUM()`
C) `AVG()`
D) All of the above

**Correct Answer:** D
**Explanation:** Most aggregate functions can be used as window functions with OVER() to calculate running totals, averages, etc.

---

### Question 40
What distinguishes `RANK()` from `DENSE_RANK()` in handling ties?

A) `RANK()` skips numbers after ties, `DENSE_RANK()` does not
B) `DENSE_RANK()` skips numbers after ties, `RANK()` does not
C) Both skip numbers identically
D) Neither handles ties

**Correct Answer:** A
**Explanation:** If two rows tie for rank 2, `RANK()` gives the next rank as 4 (skipping 3), while `DENSE_RANK()` gives 3.

---

## Section 5: SQLAlchemy ORM & Performance (10 questions)

### Question 41
What is the N+1 query problem in ORM usage?

A) Executing N queries when 1 would suffice due to lazy loading
B) Creating N+1 database connections
C) N+1 indexes on a single table
D) Using N+1 transactions for a single operation

**Correct Answer:** A
**Explanation:** Lazy loading relationships causes separate queries for each related object, leading to N+1 queries.

---

### Question 42
Which SQLAlchemy loading strategy fetches related objects in a single query using JOIN?

A) `lazyload()`
B) `selectinload()`
C) `joinedload()`
D) `noload()`

**Correct Answer:** C
**Explanation:** `joinedload()` uses SQL JOIN to fetch related objects eagerly in one query, avoiding N+1.

---

### Question 43
In SQLAlchemy, what does `session.flush()` do?

A) Commits the transaction and closes the session
B) Sends pending changes to the database but doesn't commit
C) Clears all cached objects from memory
D) Refreshes objects from the database

**Correct Answer:** B
**Explanation:** `flush()` synchronizes in-memory state with the database within a transaction, but doesn't commit.

---

### Question 44
Which SQLAlchemy feature allows executing multiple INSERT operations in a single round-trip?

A) `bulk_insert_mappings()`
B) `session.add_all()`
C) `executemany()`
D) All of the above

**Correct Answer:** D
**Explanation:** All three methods optimize bulk operations, reducing round-trips to the database.

---

### Question 45
What is the purpose of SQLAlchemy's `expire_on_commit` session setting?

A) Automatically close sessions after commit
B) Expire objects so they're refreshed on next access
C) Delete uncommitted objects
D) Prevent concurrent transactions

**Correct Answer:** B
**Explanation:** `expire_on_commit=True` marks objects as expired after commit, ensuring fresh data on next access.

---

### Question 46
Which Alembic command generates a migration script based on model changes?

A) `alembic upgrade head`
B) `alembic revision --autogenerate`
C) `alembic init`
D) `alembic current`

**Correct Answer:** B
**Explanation:** `alembic revision --autogenerate` compares models to the database and generates migration code.

---

### Question 47
What does the `pool_pre_ping` parameter do in SQLAlchemy's create_engine()?

A) Tests connections before checkout to detect dropped connections
B) Pings the database every minute
C) Warms up the connection pool at startup
D) Disables connection pooling

**Correct Answer:** A
**Explanation:** `pool_pre_ping=True` verifies connection health before use, detecting network issues or database restarts.

---

### Question 48
In SQLAlchemy relationships, what does `cascade="all, delete-orphan"` accomplish?

A) Prevents deletion of related objects
B) Automatically deletes related objects when the parent is deleted
C) Creates database-level CASCADE constraints
D) Disables foreign key checks

**Correct Answer:** B
**Explanation:** This cascade option ensures that when a parent is deleted, all related children are also deleted.

---

### Question 49
Which SQLAlchemy pattern is recommended for FastAPI dependency injection?

A) Global session object
B) Thread-local session
C) Generator function yielding a session
D) Singleton session per application

**Correct Answer:** C
**Explanation:** FastAPI's `Depends()` works best with generator functions that yield a session and clean up afterward.

---

### Question 50
What is the trade-off of using SQLAlchemy's `autoflush=False`?

A) Better control over when changes are sent to the database, but requires manual flushing
B) Faster queries but no transaction support
C) Automatic rollback on errors
D) Prevents all database writes

**Correct Answer:** A
**Explanation:** `autoflush=False` gives explicit control over flush timing but requires developers to call `flush()` manually.

---

**End of Quiz** – Review your answers and submit when ready. Good luck!
