# Kubernetes Secrets Example
#
# Secrets store sensitive data (passwords, API keys, certificates).
# NEVER commit actual secrets to version control!
# This file is a template - copy and fill with actual values.
#
# Learning Objectives:
# - Understand Secrets vs ConfigMaps
# - Create and use Secrets securely
# - Inject secrets into pods
# - Best practices for secret management

# IMPORTANT: This is an EXAMPLE file
# 1. Copy to secrets.yaml: cp secrets.yaml.example secrets.yaml
# 2. Fill in actual values (base64 encoded)
# 3. Add secrets.yaml to .gitignore
# 4. NEVER commit secrets.yaml to Git!

apiVersion: v1
kind: Secret
metadata:
  name: model-api-secrets
  namespace: ml-serving
  labels:
    app: model-api

# ========================================================================
# SECRET TYPE
# ========================================================================

# TODO: Set secret type
# Common types:
# - Opaque: arbitrary user-defined data (default, most common)
# - kubernetes.io/tls: TLS certificate and key
# - kubernetes.io/dockerconfigjson: Docker registry credentials
# - kubernetes.io/service-account-token: Service account token
type: Opaque

# ========================================================================
# SECRET DATA (Base64 Encoded)
# ========================================================================

# TODO: Add secret data
# All values must be base64 encoded!
# Encode: echo -n "my-secret-value" | base64
# Decode: echo "bXktc2VjcmV0LXZhbHVl" | base64 -d

data:
  # Example: API key for external service
  # TODO: Replace with actual base64-encoded API key
  # api-key: ""  # Example: echo -n "sk-1234567890abcdef" | base64

  # Example: Database password
  # TODO: Replace with actual base64-encoded password
  # db-password: ""  # Example: echo -n "MySecretPassword123!" | base64

  # Example: JWT secret key
  # TODO: Replace with actual base64-encoded secret
  # jwt-secret: ""  # Example: echo -n "super-secret-jwt-key" | base64

  # Example: Model download URL with credentials
  # TODO: Replace with actual base64-encoded URL
  # model-url: ""  # Example: echo -n "https://user:pass@models.example.com/model.pt" | base64

# ========================================================================
# SECRET DATA (Plain Text - Use Carefully)
# ========================================================================

# Alternative: Use stringData for plain text (automatically base64 encoded)
# WARNING: Still visible in manifests! Only slightly more convenient.

# stringData:
#   api-key: "sk-1234567890abcdef"        # NOT base64 encoded
#   db-password: "MySecretPassword123!"   # NOT base64 encoded

# Use stringData when:
# - Creating secrets manually for testing
# - Values are already plain text

# Don't use stringData when:
# - File is in version control
# - Sharing manifests publicly

---

# ============================================================================
# TLS SECRET EXAMPLE
# ============================================================================

# For SSL/TLS certificates (used with Ingress)

# apiVersion: v1
# kind: Secret
# metadata:
#   name: model-api-tls
#   namespace: ml-serving
# type: kubernetes.io/tls
# data:
#   # Base64 encoded certificate
#   tls.crt: ""  # cat cert.crt | base64 -w 0
#
#   # Base64 encoded private key
#   tls.key: ""  # cat cert.key | base64 -w 0

# Creating TLS Secret from files:
#   kubectl create secret tls model-api-tls \
#     --cert=path/to/cert.crt \
#     --key=path/to/cert.key \
#     -n ml-serving

---

# ============================================================================
# DOCKER REGISTRY SECRET EXAMPLE
# ============================================================================

# For pulling images from private Docker registries

# apiVersion: v1
# kind: Secret
# metadata:
#   name: docker-registry-secret
#   namespace: ml-serving
# type: kubernetes.io/dockerconfigjson
# data:
#   .dockerconfigjson: ""  # Base64 encoded Docker config

# Creating Docker registry Secret:
#   kubectl create secret docker-registry docker-registry-secret \
#     --docker-server=https://index.docker.io/v1/ \
#     --docker-username=myusername \
#     --docker-password=mypassword \
#     --docker-email=myemail@example.com \
#     -n ml-serving

# Using in Pod:
#   spec:
#     imagePullSecrets:
#     - name: docker-registry-secret
#     containers:
#     - name: my-container
#       image: myregistry.com/my-private-image:latest

---

# ============================================================================
# SECRET CREATION METHODS
# ============================================================================

# Method 1: From YAML file (this file)
#   kubectl apply -f secrets.yaml -n ml-serving

# Method 2: From literal values
#   kubectl create secret generic model-api-secrets \
#     --from-literal=api-key=sk-1234567890abcdef \
#     --from-literal=db-password=MyPassword123 \
#     -n ml-serving

# Method 3: From files
#   kubectl create secret generic model-api-secrets \
#     --from-file=api-key=./api-key.txt \
#     --from-file=db-password=./db-password.txt \
#     -n ml-serving

# Method 4: Using kustomize (recommended for GitOps)
#   # secretGenerator in kustomization.yaml
#   secretGenerator:
#   - name: model-api-secrets
#     literals:
#     - api-key=sk-1234567890abcdef
#     - db-password=MyPassword123

---

# ============================================================================
# USING SECRETS IN PODS
# ============================================================================

# Example Deployment using secrets:

# apiVersion: apps/v1
# kind: Deployment
# metadata:
#   name: model-api
# spec:
#   template:
#     spec:
#       containers:
#       - name: model-api
#         image: model-api:v1.0

#         # Method 1: Environment variables from Secret
#         env:
#         - name: API_KEY
#           valueFrom:
#             secretKeyRef:
#               name: model-api-secrets
#               key: api-key
#         - name: DB_PASSWORD
#           valueFrom:
#             secretKeyRef:
#               name: model-api-secrets
#               key: db-password

#         # Method 2: All secrets as environment variables
#         envFrom:
#         - secretRef:
#             name: model-api-secrets
#         # Creates env vars: api-key, db-password, etc.

#         # Method 3: Mount secrets as files
#         volumeMounts:
#         - name: secret-volume
#           mountPath: /etc/secrets
#           readOnly: true
#         # Creates files: /etc/secrets/api-key, /etc/secrets/db-password

#       volumes:
#       - name: secret-volume
#         secret:
#           secretName: model-api-secrets
#           # Optional: Specify which keys to mount
#           items:
#           - key: api-key
#             path: api-key.txt
#           - key: db-password
#             path: db-password.txt

---

# ============================================================================
# SECRET SECURITY BEST PRACTICES
# ============================================================================

# 1. NEVER commit secrets to version control
#    - Add secrets.yaml to .gitignore
#    - Use secrets.yaml.example as template
#    - Populate secrets in CI/CD or manually

# 2. Use external secret managers (production)
#    - AWS Secrets Manager
#    - GCP Secret Manager
#    - Azure Key Vault
#    - HashiCorp Vault
#    - External Secrets Operator (https://external-secrets.io/)

# 3. Enable encryption at rest
#    - Kubernetes secrets are base64 encoded (NOT encrypted!)
#    - Enable encryption at rest in etcd
#    - For EKS: Use AWS KMS
#    - For GKE: Encryption enabled by default
#    - For AKS: Use Azure Key Vault

# 4. Limit secret access with RBAC
#    - Grant secret read permissions only to necessary ServiceAccounts
#    - Use separate namespaces for different trust levels
#    - Audit secret access

# 5. Rotate secrets regularly
#    - Automated rotation (AWS Secrets Manager, Vault)
#    - Document rotation procedures
#    - Test rotation process

# 6. Use immutable secrets (Kubernetes 1.21+)
#    - Prevents accidental modification
#    - Better performance (cached, not watched)
#    - immutable: true

# 7. Scan for leaked secrets
#    - Use tools: git-secrets, truffleHog, GitGuardian
#    - Pre-commit hooks to prevent commits
#    - Scan Git history for accidentally committed secrets

---

# ============================================================================
# SECRET MANAGEMENT WORKFLOWS
# ============================================================================

# Development Workflow:
#   1. Use secrets.yaml.example as template
#   2. Create secrets.yaml locally (gitignored)
#   3. Fill with development secrets (not production!)
#   4. Apply: kubectl apply -f secrets.yaml -n ml-serving

# CI/CD Workflow:
#   1. Store secrets in CI/CD system (GitHub Secrets, GitLab CI Variables)
#   2. In pipeline, create secrets programmatically:
#      kubectl create secret generic model-api-secrets \
#        --from-literal=api-key=$API_KEY \
#        --from-literal=db-password=$DB_PASSWORD \
#        -n ml-serving

# Production Workflow (External Secrets Operator):
#   1. Store secrets in external system (AWS Secrets Manager)
#   2. Create ExternalSecret resource referencing external secret
#   3. External Secrets Operator syncs to Kubernetes Secret
#   4. Automatic rotation when external secret changes

# Example ExternalSecret:
#   apiVersion: external-secrets.io/v1beta1
#   kind: ExternalSecret
#   metadata:
#     name: model-api-secrets
#   spec:
#     secretStoreRef:
#       name: aws-secrets-manager
#       kind: SecretStore
#     target:
#       name: model-api-secrets
#     data:
#     - secretKey: api-key
#       remoteRef:
#         key: prod/model-api/api-key

---

# ============================================================================
# VIEWING AND DEBUGGING SECRETS
# ============================================================================

# List secrets:
#   kubectl get secrets -n ml-serving

# Describe secret (doesn't show values):
#   kubectl describe secret model-api-secrets -n ml-serving

# View secret (shows base64 encoded values):
#   kubectl get secret model-api-secrets -n ml-serving -o yaml

# Decode secret value:
#   kubectl get secret model-api-secrets -n ml-serving -o jsonpath='{.data.api-key}' | base64 -d

# View all keys in secret:
#   kubectl get secret model-api-secrets -n ml-serving -o json | jq -r '.data | keys[]'

# Check if pod can access secret:
#   kubectl exec <pod-name> -n ml-serving -- env | grep API_KEY
#   kubectl exec <pod-name> -n ml-serving -- cat /etc/secrets/api-key

---

# ============================================================================
# TROUBLESHOOTING
# ============================================================================

# Secret not found:
#   kubectl get secret model-api-secrets -n ml-serving
#   # Verify secret exists in correct namespace

# Pod can't read secret:
#   kubectl describe pod <pod-name> -n ml-serving
#   # Check Events for "Secret not found" error
#   # Verify secret name and key match in Deployment

# Invalid base64 encoding:
#   echo "bXktc2VjcmV0LXZhbHVl" | base64 -d
#   # Should decode successfully
#   # If not, re-encode: echo -n "value" | base64

# Environment variable not set:
#   kubectl exec <pod-name> -n ml-serving -- env
#   # Verify SECRET environment variable appears
#   # Check secretKeyRef name and key

# Permission denied:
#   kubectl auth can-i get secret model-api-secrets -n ml-serving
#   # Check RBAC permissions

---

# ============================================================================
# ALTERNATIVES TO KUBERNETES SECRETS
# ============================================================================

# 1. External Secrets Operator
#    - Syncs from external secret stores
#    - Supports AWS, GCP, Azure, Vault
#    - Automatic rotation

# 2. Sealed Secrets
#    - Encrypt secrets for Git storage
#    - Controller decrypts in cluster
#    - Safe to commit encrypted secrets

# 3. HashiCorp Vault
#    - Centralized secret management
#    - Dynamic secrets
#    - Audit logging
#    - Fine-grained access control

# 4. Cloud provider secret managers
#    - AWS Secrets Manager
#    - GCP Secret Manager
#    - Azure Key Vault
#    - Integrated with cloud IAM

# 5. SOPS (Secrets OPerationS)
#    - Encrypt YAML files
#    - Use with Git
#    - Decrypt on apply

---

# ============================================================================
# LEARNING CHECKPOINTS
# ============================================================================

# After completing this file, you should understand:
# ✓ Difference between Secrets and ConfigMaps
# ✓ How to create secrets (multiple methods)
# ✓ How to inject secrets into pods (env, volume)
# ✓ Base64 encoding/decoding
# ✓ Secret security best practices
# ✓ Why Kubernetes secrets are not actually encrypted
# ✓ External secret management solutions
# ✓ NEVER commit secrets to version control!
